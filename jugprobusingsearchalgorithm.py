# -*- coding: utf-8 -*-
"""JugProbUsingSearchAlgorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hpNMGxgC2m3Q21YDfZmV-TYJ-55Dvwcw
"""

Water Jug Problem using Search Algorithms
Objective:
Implement BFS, DFS, and A* search algorithms to solve the classic Water Jug Problem.

Jug1 capacity = 4 liters
Jug2 capacity = 3 liters
Goal = Measure exactly 2 liters


from collections import deque

JUG1 = 4
JUG2 = 3
GOAL = 1

def water_jug_bfs():
    start = (0, 0)
    visited = set()
    queue = deque([[start]])

    while queue:
        path = queue.popleft()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                queue.append(new_path)
    return None

solution = water_jug_bfs()
print("BFS Solution path:")
for step in solution:
    print(step)


BFS Solution path:
(0, 0)
(4, 0)
(1, 3)


def water_jug_dfs():
    start = (0, 0)
    stack = [[start]]
    visited = set()

    while stack:
        path = stack.pop()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state

        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                stack.append(new_path)
    return None

solution = water_jug_dfs()
print("DFS Solution path:")
for step in solution:
    print(step)


DFS Solution path:
(0, 0)
(0, 3)
(3, 0)
(3, 3)
(4, 2)
(4, 0)
(1, 3)


import heapq

def heuristic(state):
    x, y = state
    return min(abs(x - GOAL), abs(y - GOAL))

def a_star_water_jug():
    start = (0, 0)
    open_list = []
    heapq.heappush(open_list, (heuristic(start), 0, [start]))
    visited = {}

    while open_list:
        f, g, path = heapq.heappop(open_list)
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited and visited[state] <= g:
            continue
        visited[state] = g

        x, y = state
        next_states = [
            (JUG1, y),
            (x, JUG2),
            (0, y),
            (x, 0),
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            if nxt not in visited or g + 1 < visited.get(nxt, float('inf')):
                new_path = list(path)
                new_path.append(nxt)
                new_g = g + 1
                new_f = new_g + heuristic(nxt)
                heapq.heappush(open_list, (new_f, new_g, new_path))

solution = a_star_water_jug()
print("A* Solution path:")
for step in solution:
    print(step)


A* Solution path:
(0, 0)
(4, 0)
(1, 3)
Reflection Questions:
>>Compare the solution paths found by BFS, DFS, and A*.
ANS: BFS Path: (0,0) → (4,0) → (1,3) → Only 3 steps.

DFS Path: (0,0) → (0,3) → (3,0) → (3,3) → (4,2) → (4,0) → (1,3) → 7 steps, longer.

A* Path: (0,0) → (4,0) → (1,3) → Same as BFS, 3 steps.

>>Which algorithm gives the shortest path? Why?
BFS and A* both give the shortest path.

Reason:

BFS checks all states level by level, so the first time it reaches the goal → it’s guaranteed shortest.

A* uses heuristic + actual cost, so it’s guided towards the shortest path directly.

>>Which algorithm is more efficient in terms of time and memory?

Time efficiency:

A* is more efficient than BFS because heuristic guides the search, so fewer states are explored.

DFS can be fast sometimes but may go into wrong deep paths, so not reliable.

Memory efficiency:

DFS is best for memory (only keeps current path).

BFS uses the most memory (stores all states at each level).

A* uses less memory than BFS but more than DFS.